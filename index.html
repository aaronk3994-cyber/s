const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const msgOverlay = document.getElementById('msg-overlay');

// --- DATA CONFIG ---
const WEAPONS = {
    PISTOL: { pellets: 1, spread: 0, speed: 16, color: "#fff", piercing: false, name: "P" },
    SHOTGUN: { pellets: 6, spread: 0.5, speed: 11, color: "#ffaa00", piercing: false, name: "S" },
    SNIPER: { pellets: 1, spread: 0, speed: 28, color: "#00ffff", piercing: true, name: "X" }
};

// --- GAME STATE ---
let player = { x: 450, y: 275, size: 24, speed: 4.8, hasAmmo: true, alive: true, angle: 0, flash: 0 };
let enemies = [], projectiles = [], enemyLasers = [];
let score = 0, currentLevel = 1, shake = 0, weapon = WEAPONS.PISTOL;
let keys = {}, joyX = 0, joyY = 0, touchId = null;
let levelLoading = true; // Prevents the "Instant Win" bug

// --- INITIALIZATION ---
function initLevel(lvl) {
    levelLoading = true; 
    enemies = []; projectiles = []; enemyLasers = [];
    player.x = 450; player.y = 275; player.hasAmmo = true;
    
    if (lvl % 10 === 0) { // BOSS LEVEL
        enemies.push({ x: 100, y: 100, size: 60, speed: 1.2, hp: 5, isBoss: true, alive: true, lastShot: 0 });
    } else { // NORMAL
        for(let i=0; i < 2 + Math.floor(lvl * 0.5); i++) {
            // Spawn enemies at edges so they don't appear on top of player
            let ex = Math.random() > 0.5 ? -50 : 950;
            let ey = Math.random() * 550;
            enemies.push({ x: ex, y: ey, size: 22, speed: 1.2 + (lvl * 0.05), hp: 1, isBoss: false, alive: true });
        }
    }
    
    document.getElementById('lvl').innerText = lvl;
    // Small delay to let the engine realize enemies exist
    setTimeout(() => { levelLoading = false; }, 100);
}

// --- INPUTS ---
window.onkeydown = e => keys[e.key.toLowerCase()] = true;
window.onkeyup = e => keys[e.key.toLowerCase()] = false;

canvas.onmousemove = e => {
    const r = canvas.getBoundingClientRect();
    player.angle = Math.atan2((e.clientY - r.top)*(550/r.height) - player.y, (e.clientX - r.left)*(900/r.width) - player.x);
};

canvas.onmousedown = () => shoot();

// Joystick & Touch Fix
window.addEventListener('touchstart', e => {
    for(let t of e.changedTouches) {
        if(t.clientX < window.innerWidth/2 && touchId === null) {
            touchId = t.identifier;
            document.getElementById('joystick-container').style.display = 'block';
            document.getElementById('joystick-container').style.left = (t.clientX - 50)+'px';
            document.getElementById('joystick-container').style.top = (t.clientY - 50)+'px';
        } else {
            shoot();
        }
    }
}, {passive: false});

window.addEventListener('touchmove', e => {
    for(let t of e.changedTouches) {
        if(t.identifier === touchId) {
            const r = document.getElementById('joystick-container').getBoundingClientRect();
            let dx = t.clientX - (r.left + 50), dy = t.clientY - (r.top + 50);
            let d = Math.hypot(dx, dy);
            if(d > 40) { dx *= 40/d; dy *= 40/d; }
            document.getElementById('joystick-knob').style.transform = `translate(${dx}px, ${dy}px)`;
            joyX = dx/40; joyY = dy/40;
        }
    }
}, {passive: false});

window.addEventListener('touchend', e => {
    for(let t of e.changedTouches) if(t.identifier === touchId) { 
        touchId = null; joyX = 0; joyY = 0; 
        document.getElementById('joystick-container').style.display = 'none';
    }
});

function setWeapon(type) {
    weapon = WEAPONS[type];
    document.querySelectorAll('.wep-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('wep-' + weapon.name).classList.add('active');
    initLevel(currentLevel);
}

function shoot() {
    if(!player.hasAmmo || !player.alive) return;
    for(let i=0; i<weapon.pellets; i++) {
        let a = player.angle + (Math.random()-0.5) * weapon.spread;
        projectiles.push({ x: player.x, y: player.y, vx: Math.cos(a)*weapon.speed, vy: Math.sin(a)*weapon.speed, active: true, onGround: false, piercing: weapon.piercing });
    }
    player.hasAmmo = false; player.flash = 6; shake = 15;
}

// --- CORE ENGINE ---
function update() {
    if(!player.alive || levelLoading) return;
    if(shake > 0) shake *= 0.9;

    // Movement Fix
    let mx = 0, my = 0;
    if (joyX !== 0 || joyY !== 0) { mx = joyX; my = joyY; }
    else {
        if (keys['d'] || keys['arrowright']) mx = 1;
        if (keys['a'] || keys['arrowleft']) mx = -1;
        if (keys['w'] || keys['arrowup']) my = -1;
        if (keys['s'] || keys['arrowdown']) my = 1;
    }
    player.x = Math.max(20, Math.min(880, player.x + mx * player.speed));
    player.y = Math.max(20, Math.min(530, player.y + my * player.speed));

    // Bullet vs Enemy
    projectiles.forEach(p => {
        if(p.active && !p.onGround) {
            p.x += p.vx; p.y += p.vy;
            enemies.forEach(en => {
                if(en.alive && Math.hypot(p.x-en.x, p.y-en.y) < en.size) {
                    en.hp--; shake = 10;
                    if(en.hp <= 0) en.alive = false;
                    if(!p.piercing) p.onGround = true;
                }
            });
            if(p.x<0 || p.x>900 || p.y<0 || p.y>550) p.onGround = true;
        }
        if(p.onGround && Math.hypot(player.x-p.x, player.y-p.y) < 30) {
            player.hasAmmo = true; projectiles = [];
        }
    });

    // Enemy AI
    let aliveCount = 0;
    enemies.forEach(en => {
        if(!en.alive) return;
        aliveCount++;
        let a = Math.atan2(player.y-en.y, player.x-en.x);
        en.x += Math.cos(a)*en.speed; en.y += Math.sin(a)*en.speed;
        
        if(en.isBoss && Date.now() - en.lastShot > 600) {
            enemyLasers.push({ x: en.x, y: en.y, vx: Math.cos(a)*9, vy: Math.sin(a)*9 });
            en.lastShot = Date.now();
        }
        if(Math.hypot(player.x-en.x, player.y-en.y) < en.size) player.alive = false;
    });

    // Enemy Lasers
    enemyLasers.forEach((l, i) => {
        l.x += l.vx; l.y += l.vy;
        if(Math.hypot(l.x-player.x, l.y-player.y) < 15) player.alive = false;
        if(l.x<0 || l.x>900 || l.y<0 || l.y>550) enemyLasers.splice(i, 1);
    });

    // Win Check
    if(aliveCount === 0 && !levelLoading) { 
        score += currentLevel * 50; 
        currentLevel++; 
        initLevel(currentLevel); 
        document.getElementById('score').innerText = score; 
    }

    if(!player.alive) { 
        msgOverlay.innerHTML = `<span style="color:var(--danger)">WASTED</span><br><button onclick="location.reload()" style="pointer-events:auto; padding:10px; cursor:pointer">RETRY</button>`; 
    }
}

function drawAgent(x, y, angle, color, size) {
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    ctx.fillStyle = color; ctx.fillRect(-size/2, -size/2, size, size);
    ctx.fillStyle = "white"; ctx.fillRect(size/4, -size/3, size/4, size/4); ctx.fillRect(size/4, size/12, size/4, size/4);
    ctx.restore();
}

function draw() {
    ctx.save();
    if(shake > 0.5) ctx.translate(Math.random()*shake-shake/2, Math.random()*shake-shake/2);
    ctx.clearRect(0, 0, 900, 550);

    enemyLasers.forEach(l => { ctx.fillStyle = "#ff00ff"; ctx.fillRect(l.x-6, l.y-2, 12, 4); });
    projectiles.forEach(p => {
        ctx.fillStyle = p.onGround ? "gold" : weapon.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
    });

    enemies.forEach(en => { 
        if(en.alive) {
            if(en.isBoss) {
                ctx.strokeStyle = "red"; ctx.lineWidth = 4; ctx.strokeRect(en.x-30, en.y-30, 60, 60);
                ctx.fillStyle = "red"; ctx.fillRect(en.x-30, en.y-45, (en.hp/5)*60, 5);
            }
            drawAgent(en.x, en.y, Math.atan2(player.y-en.y, player.x-en.x), "#f85149", en.size); 
        }
    });

    if(player.alive) {
        if(player.flash > 0) { 
            ctx.fillStyle = `rgba(255,255,255,${player.flash/6})`; 
            ctx.beginPath(); ctx.arc(player.x+Math.cos(player.angle)*25, player.y+Math.sin(player.angle)*25, 45, 0, Math.PI*2); 
            ctx.fill(); player.flash--; 
        }
        drawAgent(player.x, player.y, player.angle, "#58a6ff", 24);
    }

    ctx.restore();
    update();
    requestAnimationFrame(draw);
}

initLevel(1);
draw();
